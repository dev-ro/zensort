# State Management Architecture

To ensure the application is scalable, maintainable, and testable, you MUST follow a structured state management approach.

## 1. State Management Progression

- **`setState`:** Use `setState` ONLY for local, ephemeral state that is confined to a single widget (e.g., the current value of a text field).
- **Provider:** For simple application state that needs to be shared across widgets, the `provider` package is an acceptable choice.
- **Riverpod/BLoC:** For complex features involving asynchronous logic and multiple state dependencies, a more robust solution is required. This project prefers a modern, compile-safe approach. **Riverpod** is the recommended solution.

## 2. Riverpod Best Practices

- **Provider Types:** When using Riverpod, prefer modern providers like `NotifierProvider` and `AsyncNotifierProvider` for managing state.
- **Immutability:** State objects managed by a provider MUST be immutable.
- **Handling Firebase Streams:** To manage real-time data from Firebase, you MUST use a `StreamProvider`. This ensures automatic lifecycle management (subscription and disposal) and provides the state as an `AsyncValue` for cleanly handling loading, data, and error states in the UI.

## 3. State Validity Mandates

- **Authenticated State Integrity:** The `Authenticated` state MUST always contain a valid, non-null `accessToken` for API-dependent features to function correctly. If a user is authenticated but the token is not immediately available (e.g., on app startup), the state management logic (BLoC/Notifier) **MUST** immediately trigger a silent refresh or re-authentication flow. An intermediate `Authenticating` or `RefreshingToken` state should be used during this process. An `Authenticated` state with a null `accessToken` is considered an invalid state and is forbidden.

## 4. **Inter-BLoC Communication (MANDATORY ARCHITECTURE RULE)**

**Direct BLoC-to-BLoC communication is STRICTLY FORBIDDEN.** This includes:
- Injecting one BLoC into another BLoC's constructor
- Subscribing to another BLoC's state stream from within a BLoC
- Calling methods or accessing properties of one BLoC from another BLoC

**REQUIRED PATTERN: Reactive Repository as Single Source of Truth**
- All cross-cutting concerns (especially authentication) MUST be managed through a reactive repository that exposes its state as a `Stream`
- Use `rxdart`'s `BehaviorSubject` to create streams that cache the latest value and immediately provide it to new subscribers
- Feature BLoCs MUST subscribe directly to these repository streams, NOT to other BLoCs
- This establishes the repository as the single source of truth and maintains complete decoupling between BLoCs

**Example of CORRECT architecture:**
```dart
// ✅ CORRECT: YouTubeBloc depends on AuthRepository, not AuthBloc
class YouTubeBloc extends Bloc<YoutubeEvent, YoutubeState> {
  final AuthRepository _authRepository;
  
  YouTubeBloc(this._authRepository) {
    _authRepository.currentUser.listen((user) {
      // React to auth changes
    });
  }
}
```

**Example of FORBIDDEN anti-pattern:**
```dart
// ❌ FORBIDDEN: Direct BLoC-to-BLoC dependency
class YouTubeBloc extends Bloc<YoutubeEvent, YoutubeState> {
  final AuthBloc _authBloc; // NEVER DO THIS
  
  YouTubeBloc(this._authBloc) {
    _authBloc.stream.listen((authState) { // FORBIDDEN
      // This creates tight coupling and violates architecture
    });
  }
}
```

## 5. Data Loading and State Coordination

- **Triggering Initial Data Loads:** For a feature's BLoC that depends on an authenticated user (e.g., `YouTubeBloc`), the initial data load **MUST NOT** be triggered by the UI's `initState` or `build` methods. This creates tight coupling with the widget lifecycle and can cause infinite loops.
- **Correct Pattern:** The feature BLoC (`YouTubeBloc`) **MUST** listen to the repository's reactive stream (`AuthRepository.currentUser`). When a non-null user is emitted, the BLoC should dispatch its own initial data loading event.
- **Race Condition Prevention:** Use `bloc_concurrency` transformers (especially `restartable()`) on event handlers that perform data fetching to prevent race conditions when authentication state changes rapidly.


